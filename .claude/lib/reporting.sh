#!/bin/bash
#
# AI Agent Reporting Library
# Generates professional reports and sends them via email
#
# Version: 1.0.0
# Author: Tom Vitso + Claude Code
# Date: 2025-11-20

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

# Detect OneDrive path dynamically (P0 optimization - fixes hardcoding issue)
detect_onedrive_path() {
    local onedrive_paths=(
        "/mnt/c/Users/$USER/OneDrive/Documents/AI-Workspace/Reports"
        "/mnt/c/Users/$USER/onedrive/documents/AI-Workspace/Reports"
        "/mnt/c/Users/thoma/OneDrive/Documents/AI-Workspace/Reports"
        "/mnt/c/Users/thoma/onedrive/documents/AI-Workspace/Reports"
        "$HOME/OneDrive/Documents/AI-Workspace/Reports"
        "$HOME/Documents/AI-Workspace/Reports"
        "/tmp/ai-workspace-reports"  # Fallback
    )

    for path in "${onedrive_paths[@]}"; do
        if [[ -d "$(dirname "$path")" ]]; then
            mkdir -p "$path" 2>/dev/null && echo "$path" && return 0
        fi
    done

    # Final fallback
    mkdir -p "/tmp/ai-workspace-reports"
    echo "/tmp/ai-workspace-reports"
}

REPORTS_DIR="${REPORTS_DIR:-$(detect_onedrive_path)}"
REPORT_DATE_FORMAT="%Y-%m-%d_%H-%M-%S"
REPORT_EMAIL_ENABLED="${REPORT_EMAIL_ENABLED:-false}"
REPORT_EMAIL_TO="${REPORT_EMAIL_TO:-}"
REPORT_EMAIL_FROM="${REPORT_EMAIL_FROM:-ai-agents@localhost}"
REPORT_EMAIL_SMTP="${REPORT_EMAIL_SMTP:-localhost}"

# Create reports directory if it doesn't exist (only if not already created)
[[ -d "$REPORTS_DIR" ]] || mkdir -p "$REPORTS_DIR"

# ============================================================================
# REPORT GENERATION
# ============================================================================

# Generate a security audit report
#
# Args:
#   $1 - Report content (markdown)
#   $2 - Codebase name/path
#   $3 - Finding count (optional)
#
# Returns:
#   Path to generated report file
#
generate_security_report() {
    local content="$1"
    local codebase="$2"
    local finding_count="${3:-N/A}"

    local timestamp=$(date +"$REPORT_DATE_FORMAT")
    local report_file="$REPORTS_DIR/security-audit_${timestamp}.md"

    # P1 Security Fix: Create report with secure permissions (600)
    # This ensures only the owner can read/write sensitive security findings
    cat > "$report_file" <<EOF
# Security Audit Report

**Generated**: $(date "+%Y-%m-%d %H:%M:%S")
**Codebase**: $codebase
**Findings**: $finding_count
**Report ID**: security-audit_${timestamp}

---

$content

---

**Report Generated By**: AI Security Analyzer Agent
**Delegation**: Gemini (pattern detection) + Claude (aggregation)
**Compliance Frameworks**: OWASP Top 10, HIPAA ยง164.312, SOC 2, NIST CSF

## Next Steps

1. Review all P0 (Critical) findings immediately
2. Plan remediation for P1 (High) findings within 7 days
3. Schedule P2 (Medium) fixes in next sprint
4. Document P3 (Low) items for future consideration

## Contact

For questions about this report, contact your security team.
EOF

    # P1 Security Fix: Set secure permissions (owner read/write only)
    chmod 600 "$report_file"

    echo "$report_file"
}

# Generate an optimization report
#
# Args:
#   $1 - Report content (markdown)
#   $2 - Codebase name/path
#   $3 - Optimization count (optional)
#
# Returns:
#   Path to generated report file
#
generate_optimization_report() {
    local content="$1"
    local codebase="$2"
    local optimization_count="${3:-N/A}"

    local timestamp=$(date +"$REPORT_DATE_FORMAT")
    local report_file="$REPORTS_DIR/optimization_${timestamp}.md"

    # P1 Security Fix: Create report with secure permissions (600)
    cat > "$report_file" <<EOF
# Performance Optimization Report

**Generated**: $(date "+%Y-%m-%d %H:%M:%S")
**Codebase**: $codebase
**Optimizations Found**: $optimization_count
**Report ID**: optimization_${timestamp}

---

$content

---

**Report Generated By**: AI Optimizer Agent
**Delegation**: Codex (GPT-5) optimization analysis + Claude (prioritization)

## Implementation Priority

- **High Impact**: Implement immediately (10x+ performance gain)
- **Medium Impact**: Schedule in current sprint (2-10x gain)
- **Low Impact**: Consider for future optimization (incremental improvements)

## Contact

For questions about this report, contact your development team.
EOF

    # P1 Security Fix: Set secure permissions (owner read/write only)
    chmod 600 "$report_file"

    echo "$report_file"
}

# Generate a code review report
#
# Args:
#   $1 - Report content (markdown)
#   $2 - Codebase name/path
#   $3 - Issue count (optional)
#
# Returns:
#   Path to generated report file
#
generate_code_review_report() {
    local content="$1"
    local codebase="$2"
    local issue_count="${3:-N/A}"

    local timestamp=$(date +"$REPORT_DATE_FORMAT")
    local report_file="$REPORTS_DIR/code-review_${timestamp}.md"

    # P1 Security Fix: Create report with secure permissions (600)
    cat > "$report_file" <<EOF
# Code Review Report

**Generated**: $(date "+%Y-%m-%d %H:%M:%S")
**Codebase**: $codebase
**Issues Found**: $issue_count
**Report ID**: code-review_${timestamp}

---

$content

---

**Report Generated By**: AI Code Reviewer Agent
**Delegation**: Multi-AI (Codex for architecture, Gemini for security, Claude for aggregation)

## Review Categories

- **Architecture**: Design patterns, maintainability, scalability
- **Security**: Vulnerabilities and best practices
- **Performance**: Optimization opportunities
- **Best Practices**: Code quality and standards

## Contact

For questions about this report, contact your code review team.
EOF

    # P1 Security Fix: Set secure permissions (owner read/write only)
    chmod 600 "$report_file"

    echo "$report_file"
}

# Generate a test execution report
#
# Args:
#   $1 - Report content (markdown)
#   $2 - Test suite name
#   $3 - Pass/Fail counts (optional)
#
# Returns:
#   Path to generated report file
#
generate_test_report() {
    local content="$1"
    local test_suite="$2"
    local pass_fail="${3:-N/A}"

    local timestamp=$(date +"$REPORT_DATE_FORMAT")
    local report_file="$REPORTS_DIR/test-execution_${timestamp}.md"

    # P1 Security Fix: Create report with secure permissions (600)
    cat > "$report_file" <<EOF
# Test Execution Report

**Generated**: $(date "+%Y-%m-%d %H:%M:%S")
**Test Suite**: $test_suite
**Results**: $pass_fail
**Report ID**: test-execution_${timestamp}

---

$content

---

**Report Generated By**: AI Test Runner Agent
**Delegation**: Hybrid (Native test tools + Codex analysis)

## Test Quality Metrics

- **Coverage**: Percentage of code tested
- **Pass Rate**: Successful tests / Total tests
- **Flaky Tests**: Tests with intermittent failures
- **Missing Coverage**: Critical code without tests

## Contact

For questions about this report, contact your QA team.
EOF

    # P1 Security Fix: Set secure permissions (owner read/write only)
    chmod 600 "$report_file"

    echo "$report_file"
}

# Generate a documentation report
#
# Args:
#   $1 - Report content (markdown)
#   $2 - Project name
#   $3 - Documentation coverage (optional)
#
# Returns:
#   Path to generated report file
#
generate_documentation_report() {
    local content="$1"
    local project="$2"
    local coverage="${3:-N/A}"

    local timestamp=$(date +"$REPORT_DATE_FORMAT")
    local report_file="$REPORTS_DIR/documentation_${timestamp}.md"

    # P1 Security Fix: Create report with secure permissions (600)
    cat > "$report_file" <<EOF
# Documentation Generation Report

**Generated**: $(date "+%Y-%m-%d %H:%M:%S")
**Project**: $project
**Coverage**: $coverage
**Report ID**: documentation_${timestamp}

---

$content

---

**Report Generated By**: AI Documentation Generator Agent
**Delegation**: Codex (technical docs) + Claude (narrative and compliance)

## Documentation Quality

- **Completeness**: All public APIs documented
- **Accuracy**: Docs match current code
- **Clarity**: Easy to understand for new team members
- **Compliance**: HIPAA and regulatory documentation

## Contact

For questions about this report, contact your documentation team.
EOF

    # P1 Security Fix: Set secure permissions (owner read/write only)
    chmod 600 "$report_file"

    echo "$report_file"
}

# ============================================================================
# EMAIL DELIVERY
# ============================================================================

# Send report via email
#
# Args:
#   $1 - Report file path
#   $2 - Email subject
#   $3 - Optional: Email recipient (overrides REPORT_EMAIL_TO)
#
# Returns:
#   0 on success, 1 on failure
#
send_report_email() {
    local report_file="$1"
    local subject="$2"
    local recipient="${3:-$REPORT_EMAIL_TO}"

    if [[ "$REPORT_EMAIL_ENABLED" != "true" ]]; then
        echo "Email delivery disabled (REPORT_EMAIL_ENABLED=$REPORT_EMAIL_ENABLED)"
        return 1
    fi

    if [[ -z "$recipient" ]]; then
        echo "No email recipient configured (REPORT_EMAIL_TO)"
        return 1
    fi

    if [[ ! -f "$report_file" ]]; then
        echo "Report file not found: $report_file"
        return 1
    fi

    # Check if mail command is available
    if command -v mail &> /dev/null; then
        # Use mail command
        mail -s "$subject" "$recipient" < "$report_file"
        echo "Report sent to $recipient via mail command"
        return 0
    elif command -v sendmail &> /dev/null; then
        # Use sendmail
        {
            echo "To: $recipient"
            echo "From: $REPORT_EMAIL_FROM"
            echo "Subject: $subject"
            echo ""
            cat "$report_file"
        } | sendmail -t
        echo "Report sent to $recipient via sendmail"
        return 0
    elif command -v mutt &> /dev/null; then
        # Use mutt
        mutt -s "$subject" "$recipient" < "$report_file"
        echo "Report sent to $recipient via mutt"
        return 0
    else
        echo "No mail client found (install mail, sendmail, or mutt)"
        echo "Report saved to: $report_file"
        return 1
    fi
}

# Send report via cloud email service (future enhancement)
#
# Args:
#   $1 - Report file path
#   $2 - Email subject
#   $3 - Email recipient
#
# Returns:
#   0 on success, 1 on failure
#
send_report_cloud_email() {
    local report_file="$1"
    local subject="$2"
    local recipient="$3"

    # Future: Integrate with SendGrid, AWS SES, or similar
    echo "Cloud email delivery not yet implemented"
    echo "Report saved to: $report_file"
    return 1
}

# ============================================================================
# REPORT UTILITIES
# ============================================================================

# List all reports
list_reports() {
    local report_type="${1:-*}"

    echo "=== Reports in $REPORTS_DIR ==="
    echo ""

    if ls "$REPORTS_DIR"/${report_type}*.md 2>/dev/null; then
        ls -lht "$REPORTS_DIR"/${report_type}*.md | head -20
    else
        echo "No reports found matching: ${report_type}*.md"
    fi
}

# Get latest report of a specific type
#
# Args:
#   $1 - Report type (security-audit, optimization, code-review, etc.)
#
# Returns:
#   Path to latest report
#
get_latest_report() {
    local report_type="$1"

    local latest=$(ls -t "$REPORTS_DIR"/${report_type}_*.md 2>/dev/null | head -1)

    if [[ -n "$latest" ]]; then
        echo "$latest"
    else
        echo ""
        return 1
    fi
}

# Archive old reports (move to archive directory)
#
# Args:
#   $1 - Days old (default: 30)
#
archive_old_reports() {
    local days_old="${1:-30}"
    local archive_dir="$REPORTS_DIR/archive"

    mkdir -p "$archive_dir"

    echo "Archiving reports older than $days_old days..."

    find "$REPORTS_DIR" -maxdepth 1 -name "*.md" -type f -mtime +$days_old -exec mv {} "$archive_dir/" \;

    local archived_count=$(ls "$archive_dir" 2>/dev/null | wc -l)
    echo "Archived $archived_count reports to $archive_dir"
}

# Convert markdown report to HTML
#
# Args:
#   $1 - Markdown report file
#
# Returns:
#   Path to HTML file
#
convert_report_to_html() {
    local md_file="$1"
    local html_file="${md_file%.md}.html"

    if command -v pandoc &> /dev/null; then
        pandoc "$md_file" -o "$html_file" --standalone --css=report-style.css
        echo "$html_file"
    else
        echo "pandoc not installed (required for HTML conversion)"
        return 1
    fi
}

# ============================================================================
# INITIALIZATION
# ============================================================================

echo "[INFO] Reporting library loaded (v1.0.0)"
echo "[INFO] Reports directory: $REPORTS_DIR"
echo "[INFO] Email delivery: $REPORT_EMAIL_ENABLED"
